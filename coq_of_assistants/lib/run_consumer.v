(* Generated by coq-of-rust
Require Import CoqOfRust.CoqOfRust.
 *)


Notation "e1 ::type[ e2 ]" := (cons e1 e2)
  (at level 0).

(*
fn main() {
    env_logger::builder()
        .filter_level(log::LevelFilter::Info)
        .init();

    // Set up your database connection pool
    let database_url = std::env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    let pool = PgPoolOptions::new()
        .max_connections(5)
        .connect(&database_url)
        .await
        .expect("Failed to create pool.");
    let redis_url = std::env::var("REDIS_URL").expect("REDIS_URL must be set");
    let client = redis::Client::open(redis_url).unwrap();
    let mut con = client.get_async_connection().await.unwrap();

    info!("Starting consumer");

    let ascii_art = r"
    ___           ___           ___                       ___           ___           ___           ___           ___           ___     
    /\  \         /\  \         /\  \          ___        /\  \         /\  \         /\  \         /\__\         /\  \         /\  \    
   /::\  \       /::\  \       /::\  \        /\  \      /::\  \        \:\  \       /::\  \       /::|  |        \:\  \       /::\  \   
  /:/\:\  \     /:/\ \  \     /:/\ \  \       \:\  \    /:/\ \  \        \:\  \     /:/\:\  \     /:|:|  |         \:\  \     /:/\ \  \  
 /::\~\:\  \   _\:\~\ \  \   _\:\~\ \  \      /::\__\  _\:\~\ \  \       /::\  \   /::\~\:\  \   /:/|:|  |__       /::\  \   _\:\~\ \  \ 
/:/\:\ \:\__\ /\ \:\ \ \__\ /\ \:\ \ \__\  __/:/\/__/ /\ \:\ \ \__\     /:/\:\__\ /:/\:\ \:\__\ /:/ |:| /\__\     /:/\:\__\ /\ \:\ \ \__\
\/__\:\/:/  / \:\ \:\ \/__/ \:\ \:\ \/__/ /\/:/  /    \:\ \:\ \/__/    /:/  \/__/ \/__\:\/:/  / \/__|:|/:/  /    /:/  \/__/ \:\ \:\ \/__/
     \::/  /   \:\ \:\__\    \:\ \:\__\   \::/__/      \:\ \:\__\     /:/  /           \::/  /      |:/:/  /    /:/  /       \:\ \:\__\  
     /:/  /     \:\/:/  /     \:\/:/  /    \:\__\       \:\/:/  /     \/__/            /:/  /       |::/  /     \/__/         \:\/:/  /  
    /:/  /       \::/  /       \::/  /      \/__/        \::/  /                      /:/  /        /:/  /                     \::/  /   
    \/__/         \/__/         \/__/                     \/__/                       \/__/         \/__/                       \/__/                                                                                                                                     
    
                                         ___                    ___                    ___     
                                        /\  \                  /\  \                  /\  \    
                                        \:\  \                 \:\  \                 \:\  \   
                                         \:\  \                 \:\  \                 \:\  \  
                                         /::\  \                /::\  \                /::\  \ 
                                        /:/\:\__\              /:/\:\__\              /:/\:\__\
                                       /:/  \/__/             /:/  \/__/             /:/  \/__/
                                      /:/  /                 /:/  /                 /:/  /     
                                      \/__/                  \/__/                  \/__/      
    
    ";

    info!("{}", &ascii_art);

    loop_through_runs(&pool, &mut con).await;
}
 *)
Definition main2 := tt.
(*   fun γ => *)
(*     (let _task_context := M.copy γ in *)
(*      let _ : M.Val unit := *)
(*        let α0 : env_logger.Builder.t := M.call env_logger.builder in *)
(*        (* let α1 : M.Val env_logger.Builder.t := M.alloc α0 in *) *)
(*        (* let α2 : mut_ref env_logger.Builder.t := *) *)
(*        (*   M.call *) *)
(*        (*     (env_logger.Builder.t::["filter_level"] *) *)
(*        (*        (borrow_mut α1) *) *)
(*        (*        log.LevelFilter.Info) in *) *)
(*        (* let α3 : unit := *) *)
(*        (*   M.call (env_logger.Builder.t::["init"] α2) in *) *)
(*        (* M.alloc α3 in *) *)
(*      let database_url : M.Val alloc.string.String.t := *)
(*        let α0 : ref str.t := M.read (mk_str "DATABASE_URL") in *)
(*        let α1 : *)
(*          core.result.Result.t *)
(*            alloc.string.String.t *)
(*            std.env.VarError.t := *)
(*          M.call (std.env.var α0) in *)
(*        let α2 : ref str.t := *)
(*          M.read (mk_str "DATABASE_URL must be set") in *)
(*        (* let α3 : alloc.string.String.t := *) *)
(*        (*   M.call *) *)
(*        (*     ((core.result.Result.t *) *)
(*        (*         alloc.string.String.t *) *)
(*        (*         std.env.VarError.t)::["expect"] *) *)
(*        (*        α1 *) *)
(*        (*        α2) in *) *)
(*        (* M.alloc α3 in *) *)
(*      let pool : *)
(*        M.Val *)
(*          (sqlx_core.pool.Pool.t *)
(*             sqlx_postgres.database.Postgres.t) := *)
(*        let α0 : _ -> M _ := *)
(*          ltac:(M.get_method (fun ℐ => *)
(*                                core.future.into_future.IntoFuture.into_future *)
(*                         (Self := _) *)
(*                         (Trait := ℐ))) in *)
(*        let α1 : *)
(*          sqlx_core.pool.options.PoolOptions.t *)
(*            sqlx_postgres.database.Postgres.t := *)
(*          M.call *)
(*            (sqlx_core.pool.options.PoolOptions.t *)
(*               sqlx_postgres.database.Postgres.t)::["new"] in *)
(*        let α2 : *)
(*          sqlx_core.pool.options.PoolOptions.t *)
(*            sqlx_postgres.database.Postgres.t := *)
(*          M.call *)
(*            ((sqlx_core.pool.options.PoolOptions.t *)
(*                sqlx_postgres.database.Postgres.t)::["max_connections"] *)
(*               α1 *)
(*               ((Integer.of_Z 5) : u32.t)) in *)
(*        let α3 : (ref alloc.string.String.t) -> M (ref _) := *)
(*          ltac:(M.get_method (fun ℐ => *)
(*                                core.ops.deref.Deref.deref *)
(*                                  (Self := alloc.string.String.t) *)
(*                                  (Trait := ℐ))) in *)
(*        let α4 : ref str.t := M.call (α3 (borrow database_url)) in *)
(*        let α5 : _ := *)
(*          M.call *)
(*            ((sqlx_core.pool.options.PoolOptions.t *)
(*                sqlx_postgres.database.Postgres.t)::["connect"] *)
(*                         α2 *)
(*                         α4) in *)
(*                   let α6 : _ := M.call (α0 α5) in *)
(*                   let α7 : M.Val _ := M.alloc α6 in *)
(*                   let α8 : *)
(*                       M.Val *)
(*                         (core.result.Result.t *)
(*                           (sqlx_core.pool.Pool.t *)
(*                             sqlx_postgres.database.Postgres.t) *)
(*                           sqlx_core.error.Error.t) := *)
(*                     match_operator *)
(*                       α7 *)
(*                       [ *)
(*                         fun γ => *)
(*                           (let __awaitee := M.copy γ in *)
(*                           M.loop *)
(*                             (let _ : M.Val unit := *)
(*                               let α0 : *)
(*                                   (core.pin.Pin.t (mut_ref _)) -> *)
(*                                     (mut_ref core.task.wake.Context.t) -> *)
(*                                     M (core.task.poll.Poll.t _) := *)
(*                                 ltac:(M.get_method (fun ℐ => *)
(*                                   core.future.future.Future.poll *)
(*                                     (Self := _) *)
(*                                     (Trait := ℐ))) in *)
(*                               let α1 : core.pin.Pin.t (mut_ref _) := *)
(*                                 M.call *)
(*                                   ((core.pin.Pin.t *)
(*                                         (mut_ref _))::["new_unchecked"] *)
(*                                     (borrow_mut __awaitee)) in *)
(*                               let α2 : core.future.ResumeTy.t := *)
(*                                 M.read _task_context in *)
(*                               let α3 : mut_ref core.task.wake.Context.t := *)
(*                                 M.call (core.future.get_context α2) in *)
(*                               let α4 : *)
(*                                   core.task.poll.Poll.t *)
(*                                     (core.result.Result.t *)
(*                                       (sqlx_core.pool.Pool.t *)
(*                                         sqlx_postgres.database.Postgres.t) *)
(*                                       sqlx_core.error.Error.t) := *)
(*                                 M.call (α0 α1 α3) in *)
(*                               let α5 : *)
(*                                   M.Val *)
(*                                     (core.task.poll.Poll.t *)
(*                                       (core.result.Result.t *)
(*                                         (sqlx_core.pool.Pool.t *)
(*                                           sqlx_postgres.database.Postgres.t) *)
(*                                         sqlx_core.error.Error.t)) := *)
(*                                 M.alloc α4 in *)
(*                               match_operator *)
(*                                 α5 *)
(*                                 [ *)
(*                                   fun γ => *)
(*                                     (let α0 := M.read γ in *)
(*                                     match α0 with *)
(*                                     | core.task.poll.Poll.Ready _ => *)
(*                                       let γ0_0 := *)
(*                                         core.task.poll.Poll.Get_Ready_0 γ in *)
(*                                       let result := M.copy γ0_0 in *)
(*                                       let α0 : M.Val never.t := M.break in *)
(*                                       let α1 := M.read α0 in *)
(*                                       let α2 : unit := never_to_any α1 in *)
(*                                       M.alloc α2 *)
(*                                     | _ => M.break_match *)
(*                                     end) : *)
(*                                     M (M.Val unit); *)
(*                                   fun γ => *)
(*                                     (let α0 := M.read γ in *)
(*                                     match α0 with *)
(*                                     | core.task.poll.Poll.Pending => M.alloc tt *)
(*                                     | _ => M.break_match *)
(*                                     end) : *)
(*                                     M (M.Val unit) *)
(*                                 ] in *)
(*                             let _ : M.Val unit := *)
(*                               let α0 : M.Val unit := M.alloc tt in *)
(*                               let α1 : M.Val core.future.ResumeTy.t := *)
(*                                 yield α0 in *)
(*                               let α2 : core.future.ResumeTy.t := M.read α1 in *)
(*                               assign _task_context α2 in *)
(*                             M.alloc tt)) : *)
(*                           M *)
(*                             (M.Val *)
(*                               (core.result.Result.t *)
(*                                 (sqlx_core.pool.Pool.t *)
(*                                   sqlx_postgres.database.Postgres.t) *)
(*                                 sqlx_core.error.Error.t)) *)
(*                       ] in *)
(*                   let α9 : *)
(*                       core.result.Result.t *)
(*                         (sqlx_core.pool.Pool.t *)
(*                           sqlx_postgres.database.Postgres.t) *)
(*                         sqlx_core.error.Error.t := *)
(*                     M.read α8 in *)
(*                   let α10 : ref str.t := *)
(*                     M.read (mk_str "Failed to create pool.") in *)
(*                   let α11 : *)
(*                       sqlx_core.pool.Pool.t sqlx_postgres.database.Postgres.t := *)
(*                     M.call *)
(*                       ((core.result.Result.t *)
(*                             (sqlx_core.pool.Pool.t *)
(*                               sqlx_postgres.database.Postgres.t) *)
(*                             sqlx_core.error.Error.t)::["expect"] *)
(*                         α9 *)
(*                         α10) in *)
(*                   M.alloc α11 in *)
(*                 let redis_url : M.Val alloc.string.String.t := *)
(*                   let α0 : ref str.t := M.read (mk_str "REDIS_URL") in *)
(*                   let α1 : *)
(*                       core.result.Result.t *)
(*                         alloc.string.String.t *)
(*                         std.env.VarError.t := *)
(*                     M.call (std.env.var α0) in *)
(*                   let α2 : ref str.t := *)
(*                     M.read (mk_str "REDIS_URL must be set") in *)
(*                   let α3 : alloc.string.String.t := *)
(*                     M.call *)
(*                       ((core.result.Result.t *)
(*                             alloc.string.String.t *)
(*                             std.env.VarError.t)::["expect"] *)
(*                         α1 *)
(*                         α2) in *)
(*                   M.alloc α3 in *)
(*                 let client : M.Val redis.client.Client.t := *)
(*                   let α0 : alloc.string.String.t := M.read redis_url in *)
(*                   let α1 : *)
(*                       core.result.Result.t *)
(*                         redis.client.Client.t *)
(*                         redis.types.RedisError.t := *)
(*                     M.call (redis.client.Client.t::["open"] α0) in *)
(*                   let α2 : redis.client.Client.t := *)
(*                     M.call *)
(*                       ((core.result.Result.t *)
(*                             redis.client.Client.t *)
(*                             redis.types.RedisError.t)::["unwrap"] *)
(*                         α1) in *)
(*                   M.alloc α2 in *)
(*                 let con : *)
(*                     M.Val *)
(*                       (redis.aio.connection.Connection.t *)
(*                         (core.pin.Pin.t *)
(*                           (alloc.boxed.Box.t *)
(*                             (dyn [redis.aio.AsyncStream.Trait]) *)
(*                             alloc.alloc.Global.t))) := *)
(*                   let α0 : _ -> M _ := *)
(*                     ltac:(M.get_method (fun ℐ => *)
(*                       core.future.into_future.IntoFuture.into_future *)
(*                         (Self := _) *)
(*                         (Trait := ℐ))) in *)
(*                   let α1 : _ := *)
(*                     M.call *)
(*                       (redis.client.Client.t::["get_async_connection"] *)
(*                         (borrow client)) in *)
(*                   let α2 : _ := M.call (α0 α1) in *)
(*                   let α3 : M.Val _ := M.alloc α2 in *)
(*                   let α4 : *)
(*                       M.Val *)
(*                         (core.result.Result.t *)
(*                           (redis.aio.connection.Connection.t *)
(*                             (core.pin.Pin.t *)
(*                               (alloc.boxed.Box.t *)
(*                                 (dyn [redis.aio.AsyncStream.Trait]) *)
(*                                 alloc.alloc.Global.t))) *)
(*                           redis.types.RedisError.t) := *)
(*                     match_operator *)
(*                       α3 *)
(*                       [ *)
(*                         fun γ => *)
(*                           (let __awaitee := M.copy γ in *)
(*                           M.loop *)
(*                             (let _ : M.Val unit := *)
(*                               let α0 : *)
(*                                   (core.pin.Pin.t (mut_ref _)) -> *)
(*                                     (mut_ref core.task.wake.Context.t) -> *)
(*                                     M (core.task.poll.Poll.t _) := *)
(*                                 ltac:(M.get_method (fun ℐ => *)
(*                                   core.future.future.Future.poll *)
(*                                     (Self := _) *)
(*                                     (Trait := ℐ))) in *)
(*                               let α1 : core.pin.Pin.t (mut_ref _) := *)
(*                                 M.call *)
(*                                   ((core.pin.Pin.t *)
(*                                         (mut_ref _))::["new_unchecked"] *)
(*                                     (borrow_mut __awaitee)) in *)
(*                               let α2 : core.future.ResumeTy.t := *)
(*                                 M.read _task_context in *)
(*                               let α3 : mut_ref core.task.wake.Context.t := *)
(*                                 M.call (core.future.get_context α2) in *)
(*                               let α4 : *)
(*                                   core.task.poll.Poll.t *)
(*                                     (core.result.Result.t *)
(*                                       (redis.aio.connection.Connection.t *)
(*                                         (core.pin.Pin.t *)
(*                                           (alloc.boxed.Box.t *)
(*                                             (dyn [redis.aio.AsyncStream.Trait]) *)
(*                                             alloc.alloc.Global.t))) *)
(*                                       redis.types.RedisError.t) := *)
(*                                 M.call (α0 α1 α3) in *)
(*                               let α5 : *)
(*                                   M.Val *)
(*                                     (core.task.poll.Poll.t *)
(*                                       (core.result.Result.t *)
(*                                         (redis.aio.connection.Connection.t *)
(*                                           (core.pin.Pin.t *)
(*                                             (alloc.boxed.Box.t *)
(*                                               (dyn *)
(*                                                 [redis.aio.AsyncStream.Trait]) *)
(*                                               alloc.alloc.Global.t))) *)
(*                                         redis.types.RedisError.t)) := *)
(*                                 M.alloc α4 in *)
(*                               match_operator *)
(*                                 α5 *)
(*                                 [ *)
(*                                   fun γ => *)
(*                                     (let α0 := M.read γ in *)
(*                                     match α0 with *)
(*                                     | core.task.poll.Poll.Ready _ => *)
(*                                       let γ0_0 := *)
(*                                         core.task.poll.Poll.Get_Ready_0 γ in *)
(*                                       let result := M.copy γ0_0 in *)
(*                                       let α0 : M.Val never.t := M.break in *)
(*                                       let α1 := M.read α0 in *)
(*                                       let α2 : unit := never_to_any α1 in *)
(*                                       M.alloc α2 *)
(*                                     | _ => M.break_match *)
(*                                     end) : *)
(*                                     M (M.Val unit); *)
(*                                   fun γ => *)
(*                                     (let α0 := M.read γ in *)
(*                                     match α0 with *)
(*                                     | core.task.poll.Poll.Pending => M.alloc tt *)
(*                                     | _ => M.break_match *)
(*                                     end) : *)
(*                                     M (M.Val unit) *)
(*                                 ] in *)
(*                             let _ : M.Val unit := *)
(*                               let α0 : M.Val unit := M.alloc tt in *)
(*                               let α1 : M.Val core.future.ResumeTy.t := *)
(*                                 yield α0 in *)
(*                               let α2 : core.future.ResumeTy.t := M.read α1 in *)
(*                               assign _task_context α2 in *)
(*                             M.alloc tt)) : *)
(*                           M *)
(*                             (M.Val *)
(*                               (core.result.Result.t *)
(*                                 (redis.aio.connection.Connection.t *)
(*                                   (core.pin.Pin.t *)
(*                                     (alloc.boxed.Box.t *)
(*                                       (dyn [redis.aio.AsyncStream.Trait]) *)
(*                                       alloc.alloc.Global.t))) *)
(*                                 redis.types.RedisError.t)) *)
(*                       ] in *)
(*                   let α5 : *)
(*                       core.result.Result.t *)
(*                         (redis.aio.connection.Connection.t *)
(*                           (core.pin.Pin.t *)
(*                             (alloc.boxed.Box.t *)
(*                               (dyn [redis.aio.AsyncStream.Trait]) *)
(*                               alloc.alloc.Global.t))) *)
(*                         redis.types.RedisError.t := *)
(*                     M.read α4 in *)
(*                   let α6 : *)
(*                       redis.aio.connection.Connection.t *)
(*                         (core.pin.Pin.t *)
(*                           (alloc.boxed.Box.t *)
(*                             (dyn [redis.aio.AsyncStream.Trait]) *)
(*                             alloc.alloc.Global.t)) := *)
(*                     M.call *)
(*                       ((core.result.Result.t *)
(*                             (redis.aio.connection.Connection.t *)
(*                               (core.pin.Pin.t *)
(*                                 (alloc.boxed.Box.t *)
(*                                   (dyn [redis.aio.AsyncStream.Trait]) *)
(*                                   alloc.alloc.Global.t))) *)
(*                             redis.types.RedisError.t)::["unwrap"] *)
(*                         α5) in *)
(*                   M.alloc α6 in *)
(*                 let _ : M.Val unit := *)
(*                   let lvl : M.Val log.Level.t := M.alloc log.Level.Info in *)
(*                   let α0 : *)
(*                       (ref log.Level.t) -> *)
(*                         (ref log.LevelFilter.t) -> *)
(*                         M bool.t := *)
(*                     ltac:(M.get_method (fun ℐ => *)
(*                       core.cmp.PartialOrd.le *)
(*                         (Self := log.Level.t) *)
(*                         (Rhs := log.LevelFilter.t) *)
(*                         (Trait := ℐ))) in *)
(*                   let α1 : bool.t := *)
(*                     M.call (α0 (borrow lvl) (borrow log.STATIC_MAX_LEVEL)) in *)
(*                   let α2 : *)
(*                       (ref log.Level.t) -> *)
(*                         (ref log.LevelFilter.t) -> *)
(*                         M bool.t := *)
(*                     ltac:(M.get_method (fun ℐ => *)
(*                       core.cmp.PartialOrd.le *)
(*                         (Self := log.Level.t) *)
(*                         (Rhs := log.LevelFilter.t) *)
(*                         (Trait := ℐ))) in *)
(*                   let α3 : log.LevelFilter.t := M.call log.max_level in *)
(*                   let α4 : M.Val log.LevelFilter.t := M.alloc α3 in *)
(*                   let α5 : bool.t := M.call (α2 (borrow lvl) (borrow α4)) in *)
(*                   let α6 : M.Val bool.t := M.alloc (BinOp.Pure.and α1 α5) in *)
(*                   let α7 : bool.t := M.read (use α6) in *)
(*                   if α7 then *)
(*                     let _ : M.Val unit := *)
(*                       let α0 : ref str.t := *)
(*                         M.read (mk_str "Starting consumer") in *)
(*                       let α1 : M.Val (array (ref str.t)) := M.alloc [ α0 ] in *)
(*                       let α2 : core.fmt.Arguments.t := *)
(*                         M.call *)
(*                           (core.fmt.Arguments.t::["new_const"] *)
(*                             (pointer_coercion "Unsize" (borrow α1))) in *)
(*                       let α3 : log.Level.t := M.read lvl in *)
(*                       let α4 : ref str.t := M.read (mk_str "run_consumer") in *)
(*                       let α5 : ref str.t := M.read (mk_str "run_consumer") in *)
(*                       let α6 : ref str.t := *)
(*                         M.read *)
(*                           (mk_str "assistants-core/src/bin/run_consumer.rs") in *)
(*                       let α7 : *)
(*                           M.Val (((ref str.t) * (ref str.t)) * (ref str.t)) := *)
(*                         M.alloc (α4, α5, α6) in *)
(*                       let α8 : unit := *)
(*                         M.call *)
(*                           (log.__private_api.log *)
(*                             α2 *)
(*                             α3 *)
(*                             (borrow α7) *)
(*                             ((Integer.of_Z 30) : u32.t) *)
(*                             core.option.Option.None) in *)
(*                       M.alloc α8 in *)
(*                     M.alloc tt *)
(*                   else *)
(*                     M.alloc tt in *)
(*                 let ascii_art : M.Val (ref str.t) := *)
(*                   M.copy *)
(*                     (mk_str *)
(*                 let _ : M.Val unit := *)
(*                   let lvl : M.Val log.Level.t := M.alloc log.Level.Info in *)
(*                   let α0 : *)
(*                       (ref log.Level.t) -> *)
(*                         (ref log.LevelFilter.t) -> *)
(*                         M bool.t := *)
(*                     ltac:(M.get_method (fun ℐ => *)
(*                       core.cmp.PartialOrd.le *)
(*                         (Self := log.Level.t) *)
(*                         (Rhs := log.LevelFilter.t) *)
(*                         (Trait := ℐ))) in *)
(*                   let α1 : bool.t := *)
(*                     M.call (α0 (borrow lvl) (borrow log.STATIC_MAX_LEVEL)) in *)
(*                   let α2 : *)
(*                       (ref log.Level.t) -> *)
(*                         (ref log.LevelFilter.t) -> *)
(*                         M bool.t := *)
(*                     ltac:(M.get_method (fun ℐ => *)
(*                       core.cmp.PartialOrd.le *)
(*                         (Self := log.Level.t) *)
(*                         (Rhs := log.LevelFilter.t) *)
(*                         (Trait := ℐ))) in *)
(*                   let α3 : log.LevelFilter.t := M.call log.max_level in *)
(*                   let α4 : M.Val log.LevelFilter.t := M.alloc α3 in *)
(*                   let α5 : bool.t := M.call (α2 (borrow lvl) (borrow α4)) in *)
(*                   let α6 : M.Val bool.t := M.alloc (BinOp.Pure.and α1 α5) in *)
(*                   let α7 : bool.t := M.read (use α6) in *)
(*                   if α7 then *)
(*                     let _ : M.Val unit := *)
(*                       let α0 : ref str.t := M.read (mk_str "") in *)
(*                       let α1 : M.Val (array (ref str.t)) := M.alloc [ α0 ] in *)
(*                       let α2 : M.Val (ref (ref str.t)) := *)
(*                         M.alloc (borrow ascii_art) in *)
(*                       let α3 : core.fmt.rt.Argument.t := *)
(*                         M.call *)
(*                           (core.fmt.rt.Argument.t::["new_display"] *)
(*                             (borrow α2)) in *)
(*                       let α4 : M.Val (array core.fmt.rt.Argument.t) := *)
(*                         M.alloc [ α3 ] in *)
(*                       let α5 : core.fmt.Arguments.t := *)
(*                         M.call *)
(*                           (core.fmt.Arguments.t::["new_v1"] *)
(*                             (pointer_coercion "Unsize" (borrow α1)) *)
(*                             (pointer_coercion "Unsize" (borrow α4))) in *)
(*                       let α6 : log.Level.t := M.read lvl in *)
(*                       let α7 : ref str.t := M.read (mk_str "run_consumer") in *)
(*                       let α8 : ref str.t := M.read (mk_str "run_consumer") in *)
(*                       let α9 : ref str.t := *)
(*                         M.read *)
(*                           (mk_str "assistants-core/src/bin/run_consumer.rs") in *)
(*                       let α10 : *)
(*                           M.Val (((ref str.t) * (ref str.t)) * (ref str.t)) := *)
(*                         M.alloc (α7, α8, α9) in *)
(*                       let α11 : unit := *)
(*                         M.call *)
(*                           (log.__private_api.log *)
(*                             α5 *)
(*                             α6 *)
(*                             (borrow α10) *)
(*                             ((Integer.of_Z 57) : u32.t) *)
(*                             core.option.Option.None) in *)
(*                       M.alloc α11 in *)
(*                     M.alloc tt *)
(*                   else *)
(*                     M.alloc tt in *)
(*                 let _ : M.Val unit := *)
(*                   let α0 : _ -> M _ := *)
(*                     ltac:(M.get_method (fun ℐ => *)
(*                       core.future.into_future.IntoFuture.into_future *)
(*                         (Self := _) *)
(*                         (Trait := ℐ))) in *)
(*                   let α1 : _ := *)
(*                     M.call *)
(*                       (assistants_core.executor.loop_through_runs *)
(*                         (borrow pool) *)
(*                         (borrow_mut con)) in *)
(*                   let α2 : _ := M.call (α0 α1) in *)
(*                   let α3 : M.Val _ := M.alloc α2 in *)
(*                   match_operator *)
(*                     α3 *)
(*                     [ *)
(*                       fun γ => *)
(*                         (let __awaitee := M.copy γ in *)
(*                         M.loop *)
(*                           (let _ : M.Val unit := *)
(*                             let α0 : *)
(*                                 (core.pin.Pin.t (mut_ref _)) -> *)
(*                                   (mut_ref core.task.wake.Context.t) -> *)
(*                                   M (core.task.poll.Poll.t _) := *)
(*                               ltac:(M.get_method (fun ℐ => *)
(*                                 core.future.future.Future.poll *)
(*                                   (Self := _) *)
(*                                   (Trait := ℐ))) in *)
(*                             let α1 : core.pin.Pin.t (mut_ref _) := *)
(*                               M.call *)
(*                                 ((core.pin.Pin.t (mut_ref _))::["new_unchecked"] *)
(*                                   (borrow_mut __awaitee)) in *)
(*                             let α2 : core.future.ResumeTy.t := *)
(*                               M.read _task_context in *)
(*                             let α3 : mut_ref core.task.wake.Context.t := *)
(*                               M.call (core.future.get_context α2) in *)
(*                             let α4 : core.task.poll.Poll.t unit := *)
(*                               M.call (α0 α1 α3) in *)
(*                             let α5 : M.Val (core.task.poll.Poll.t unit) := *)
(*                               M.alloc α4 in *)
(*                             match_operator *)
(*                               α5 *)
(*                               [ *)
(*                                 fun γ => *)
(*                                   (let α0 := M.read γ in *)
(*                                   match α0 with *)
(*                                   | core.task.poll.Poll.Ready _ => *)
(*                                     let γ0_0 := *)
(*                                       core.task.poll.Poll.Get_Ready_0 γ in *)
(*                                     let result := M.copy γ0_0 in *)
(*                                     let α0 : M.Val never.t := M.break in *)
(*                                     let α1 := M.read α0 in *)
(*                                     let α2 : unit := never_to_any α1 in *)
(*                                     M.alloc α2 *)
(*                                   | _ => M.break_match *)
(*                                   end) : *)
(*                                   M (M.Val unit); *)
(*                                 fun γ => *)
(*                                   (let α0 := M.read γ in *)
(*                                   match α0 with *)
(*                                   | core.task.poll.Poll.Pending => M.alloc tt *)
(*                                   | _ => M.break_match *)
(*                                   end) : *)
(*                                   M (M.Val unit) *)
(*                               ] in *)
(*                           let _ : M.Val unit := *)
(*                             let α0 : M.Val unit := M.alloc tt in *)
(*                             let α1 : M.Val core.future.ResumeTy.t := *)
(*                               yield α0 in *)
(*                             let α2 : core.future.ResumeTy.t := M.read α1 in *)
(*                             assign _task_context α2 in *)
(*                           M.alloc tt)) : *)
(*                         M (M.Val unit) *)
(*                     ] in *)
(*                 let α0 : M.Val unit := M.alloc tt in *)
(*                 M.read α0) : *)
(*                 M unit. *)
            
(* Definition main : M unit := *)
(*   let return_ := M.return_ (R := unit) in *)
(*   M.catch_return *)
(*     (let body : M.Val type not implemented := *)
(*       M.alloc *)
(*         (fun (α0 : core.future.ResumeTy.t) => *)
(*           (let α0 := M.alloc α0 in *)
(*           match_operator *)
(*             α0 *)
(*             ) : *)
(*           M unit) in *)
(*     let α0 : tokio.runtime.builder.Builder.t := *)
(*       M.call tokio.runtime.builder.Builder.t::["new_multi_thread"] in *)
(*     let α1 : M.Val tokio.runtime.builder.Builder.t := M.alloc α0 in *)
(*     let α2 : mut_ref tokio.runtime.builder.Builder.t := *)
(*       M.call *)
(*         (tokio.runtime.builder.Builder.t::["enable_all"] (borrow_mut α1)) in *)
(*     let α3 : *)
(*         core.result.Result.t *)
(*           tokio.runtime.runtime.Runtime.t *)
(*           std.io.error.Error.t := *)
(*       M.call (tokio.runtime.builder.Builder.t::["build"] α2) in *)
(*     let α4 : ref str.t := M.read (mk_str "Failed building the Runtime") in *)
(*     let α5 : tokio.runtime.runtime.Runtime.t := *)
(*       M.call *)
(*         ((core.result.Result.t *)
(*               tokio.runtime.runtime.Runtime.t *)
(*               std.io.error.Error.t)::["expect"] *)
(*           α3 *)
(*           α4) in *)
(*     let α6 : M.Val tokio.runtime.runtime.Runtime.t := M.alloc α5 in *)
(*     let α7 : type not implemented := M.read body in *)
(*     let α8 : unit := *)
(*       M.call (tokio.runtime.runtime.Runtime.t::["block_on"] (borrow α6) α7) in *)
(*     let α9 : M.Val never.t := return_ α8 in *)
(*     let α10 := M.read α9 in *)
(*     let α11 : unit := never_to_any α10 in *)
(*     let α0 : M.Val unit := M.alloc α11 in *)
(*     M.read α0). *)
